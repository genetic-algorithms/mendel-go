# Mendel's Accountant default input file
# This is in TOML format (https://github.com/BurntSushi/toml)

[basic]
                      case_id = "defaults"   # identify the run. Also used as part of the default data_file_path.
                     pop_size = 1000      # initial or fixed population size. For tribes/parralel runs (not currently supported) this is the size of each tribe
              num_generations = 20     # the number of generations to run the simulation for. In the special case of pop_growth_model==exponential, this value can be 0 which indicates the run should continue until max_pop_size is reached.

[mutations]
                    mutn_rate = 10.0    # total new mutations per individual per generation
              mutn_rate_model = "poisson"   # fixed (mutn_rate rounded to int), or poisson
                frac_fav_mutn = 0.001   # fraction of total number of mutations that are favorable
             fraction_neutral = 0.0     # fraction of total number of mutations that are neutral
                  genome_size = 0.3E+09     # number of functional nucleotides in 1 set/half of chromosomes. Used to set certain other factors, like the weibull fitness effect.
         fitness_effect_model = "weibull"    # fixed (set uniform_fitness_effect_*), uniform (even distribution with uniform_fitness_effect_* as max), or weibull. The parameter fitness_distrib_type was previously used for this.
   uniform_fitness_effect_del = 0.0001   # for fitness_effect_model=fixed specifies all deleterious mutations should have the same effect. For fitness_effect_model=uniform the fitness effect is between 0 and this number.
   uniform_fitness_effect_fav = 0.0001   # for fitness_effect_model=fixed specifies all deleterious mutations should have the same effect. For fitness_effect_model=uniform the fitness effect is between 0 and this number.
    high_impact_mutn_fraction = 0.01    # the fraction of mutations that have significant/measurable effect on the fitness. Used in weibull fitness effect distribution.
   high_impact_mutn_threshold = 0.01    # not sure of the effect this has?? Used in weibull fitness effect distribution.
         max_fav_fitness_gain = 0.1     # the fitness gain of each favorable mutation will range between 0 and this number?? Used in weibull fitness effect distribution.
           fraction_recessive = 0.5     # what percentage of new mutations are recessive vs. dominant
  recessive_hetero_expression = 0.1     # the factor to multiply the recessive mutation fitness effect by.
   dominant_hetero_expression = 0.9     # the factor to multiply the dominant mutation fitness effect by.
     multiplicative_weighting = 0.0     # teaching only -  if 0.0 combine mutations additively, if 1.0 combine mutations multiplicatively (not currently supported), if inbetween partially combine mutation fitness multiplicatively as well as additively (not currently supported)
        synergistic_epistasis = false   # teaching only - if true, mutations on the same linkage blocks have more than additive effect - not currently supported
         se_nonlinked_scaling = 0.0     # not currently supported
            se_linked_scaling = 0.0     # not currently supported
         num_initial_fav_mutn = 0       # the number of favorable mutations initially in population 0 - not currently supported
             upload_mutations = false   # give generation 0 an initial set of mutations - not currently supported
              allow_back_mutn = false   # teaching only - allow existing mutated nucleotide sites to be mutated again - not currently supported
        polygenic_beneficials = false   # teaching only - not currently supported
               polygenic_init = "AAAAAA"    # teaching only - not currently supported
             polygenic_target = "TCGTCG"    # teaching only - not currently supported
             polygenic_effect = 0.001   # teaching only - not currently supported

[selection]
        fraction_random_death = 0.0     # applied to the reproductive_rate
  fitness_dependent_fertility = false   # low priority - if true, make fertility decline with fitness decline - not currently supported
             selection_model = "spps"       # *** support ssps and partial trunc - fulltrunc (full truncation), ups (unrestricted probability selection), spps (strict proportionality probability selection - not supported), partialtrunc (partial truncation selection - not supported)
                 heritability = 0.2     # used in every selection_model, what percentage effect the fitness from mutations should have on selection (the rest is chance), but this value is multiplied by the fitness variance, which is quite small
            non_scaling_noise = 0.05    # used in every selection_model, how much random chance affects selection, in a way that does not scale with fitness
     partial_truncation_value = 0.5     # used in selection_model==partialtrunc, an individual's fitness is divided by partial_truncation_value + (1. - partial_truncation_value)*randomnum(1)

[population]
            reproductive_rate = 2.0     # how many offspring per individual (times 2 for both parents). This combined with fraction_random_death determines the average num of offspring
          num_offspring_model = "fixed"  # fixed (rounded to int - default and what mendel-f90 uses), uniform (even distribution), or fitness (weighted according to fitness - not currently supported)
          recombination_model = 3      # someday - clonal = 1, suppressed = 2, full_sexual = 3 (only currently supporting 3)
  fraction_self_fertilization = 0.0     # teaching only - hermaphroditic, used for recombination_model 2 and 3 - not currently supported
              crossover_model = "partial"  # none (no crossover), full (each LB has a 50/50 chance of coming from dad or mom), partial (mean_num_crossovers per chromosome pair)
          mean_num_crossovers = 2       # only used for crossover_model=partial, the average number of crossovers per chromosome PAIR during Meiosis 1 Metaphase
    haploid_chromosome_number = 23      # number of chromosomes in 1 set/half (e.g. in a gamete)
         num_linkage_subunits = 989      # total number of linkage blocks in 1 half of an individual's genome. Must be a multiple of num chromosomes. 989 = 43 * 23
      num_contrasting_alleles = 0       # number of initial contrasting alleles (pairs) given to each individual. Used to start the pop with pre-existing diversity
     initial_alleles_pop_frac = 1.0     # used with num_contrasting_alleles - the fraction of the initial population that should have num_contrasting_alleles alleles
 initial_allele_fitness_model = "uniform"   # how to calculate the fitness effect for initial alleles - the only currently supported model is uniform (random values that average to max_total_fitness_increase / num_contrasting_alleles)
   max_total_fitness_increase = 0.1       # used with num_contrasting_alleles for allele_fitness_model=uniform - the total fitness effect of all of the favorable initial alleles in an individual
             pop_growth_model = "none"       # none (no pop growth), exponential (exponential growth model), capacity (carrying-capacity model), founders (founders effect)
              pop_growth_rate = 0.0     # growth rate each generation (e.g. 1.05 is 5% increase), used for pop_growth_model==exponential, capacity, and founders.
             pop_growth_rate2 = 0.0     # growth rate each generation (e.g. 1.05 is 5% increase), used for pop_growth_model==founders.
                 max_pop_size = 0       # used for pop_growth_model==exponential. The run will stop when this is reached or num_generations is reached, whichever comes first. Set to 0 for no max.
            carrying_capacity = 1000    # the population size limit that pop_growth_model==capacity and founders should approach. See https://en.wikipedia.org/wiki/Carrying_capacity for an overview.
#               bottleneck_yes = false   # delete this if we do not need cyclic bottleneck
        bottleneck_generation = 0       # the generation number at which the pop size bottleneck should start. Use 0 for no bottleneck. Currently only used for pop_growth_model==founders
          bottleneck_pop_size = 0       # the population size during the bottleneck
   num_bottleneck_generations = 1       # the number of generations the bottleneck should last

[substructure]
                  is_parallel = false   # not currently supported
            homogenous_tribes = true    # evenly divided - not currently supported
          num_indiv_exchanged = 1       # not currently supported
        migration_generations = 10      # not currently supported
              migration_model = 1       # not currently supported
           tribal_competition = false   # not needed now - not currently supported
               tribal_fission = false   # not currently supported
            tc_scaling_factor = 0.0     # not needed now - not currently supported
           group_heritability = 0.0     # not needed now - not currently supported
          social_bonus_factor = 1.0     # not needed now - not currently supported

[computation]
           tracking_threshold = 0.0     # below this fitness effect value, near neutral mutations will be pooled into the cumulative fitness of the LB, instead of tracked individually. This saves on memory and computation time, but some stats will not be available. This value is automatically set to a high value if allele-bins/ output is not requested, because there is no benefit to tracking in that case.
               track_neutrals = true   # if false, only keep a cumulative count of neutral mutations in each LB
         extinction_threshold = 0.0     # If the tribe or population fitness falls below this value, consider it extinct and stop the simulation - not currently supported
                  num_threads = 0       # number of concurrent threads to use in the run: 0 (equal to the number of CPUs), 1 (single-threaded), 2-n (explicitly set the number of threads to use)
           random_number_seed = 42      # If random_number_seed==0 we use a truly random seed, otherwise it will use the same sequence each run
                 restart_case = false   # not needed for now - if true, read restart file and continue run - not currently supported
          restart_dump_number = 0       # not needed for now - fortran file number for restart dump file - not currently supported
                    verbosity = 1      # higher number means more verbose, 9 is essentially debug
               data_file_path = ""     # where the output files should go. Will create this directory if necessary. If blank, will default to ./test/output/<case_id>
              files_to_output = "mendel.fit,allele-bins/"        # list of files (separated by commas) that should be generated. The filenames have fixed meanings: mendel.hst: general stats for each gen, mendel.fit: only fitness stats (faster), allele-bins/: a set of plot files showing the distribution of alleles throughout the pop
             plot_allele_gens = 0     # Only used if allele-bins/ is in files_to_output: Output allele frequencies every n generations (and the last generation). If set to 0, output once at the end of the run. Temorarily only 0 is supported.
          performance_profile = ""       # generate profile stats: empty string (no profiling), cpu, mem, or block
      transfer_linkage_blocks = true    # temporary setting - true: when possible transfer ownership of LB to child instead of copying it
                     force_gc = true   # if true, explicitly run go garbage collection after mating each generation. Otherwise GC kicks in whenever it hits the target percentage (which can be specified by GOGC). Setting this to true can cut memory usage almost in half (because you don't have unused objects from the previous gen when you start the next gen), but it also increase the time some.
